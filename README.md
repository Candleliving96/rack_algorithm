# rack_algorithm
Note: Code is currently a bit messy and difficult to follow. I am currently working on cleaning it up and adding descriptive comments/function contracts.

The problem:

A researcher at a local hospital expressed to me their desire for an automated rack distribution algorithm. They frequently receive data about a large amount of racks (~700) at a time, each of which contain anywhere from 1 to 95 samples. Typically, the number of racks containing each sample number increases as the sample number decreases - so there are hundreds of 1-sample racks, slightly fewer 2-sample racks, fewer 3-sample racks, etc. By the time it gets to 30-sample racks, the number of racks containing that sample frequency is very low. Their task is to combine these lower-sample racks into other racks that are as full as possible (a full rack has 96), while also minimizing the number of batches it takes. These batches must consist of 20 racks or less, which means they could combine 19 "source" racks into 1 "destination" rack, 18 "source" racks into 2 "destination" racks, etc.

The solution:

Based on the information given about the typical sample distribution, I devised an algorithm that efficiently distributes source racks into destination racks. The algorithm first reads in rack data and create a new Source_Rack object for each instance, keeping track of the rack id and the sample number. It then collects data about the number of racks with each number of samples and stores it in a "sample_frequencies" array. The Source_Rack and sample_freqency structures are a part of the Program class, along with a Batch class that can hold a list of Source_Racks and a testing_array vector that the program uses to try out different sample combinations. As different numbers are added and removed from the testing array, the sample frequencies array is updated accordingly. (Note that the testing array only contains ints that represent the sample numbers of the source racks, so no source racks are added to the batch until the combination is finalized).

For each batch, the program chooses the highest number of source racks it can use if it adds the largest sample rack available to the testing array and fills the rest of the spots with the lowest-sample racks available. For example, if the highest sample rack has 94 samples, then there are 18 spots left at most, which the program will fill with 1's. Now, the total number of samples is 112, which is greater than the 96 spots available with only 1 destination rack, meaning we need to decrease the number of source racks to 18. The program tries again with 18 source racks and 2 destination racks - the total samples is 111, which is less than the 192 spots available with 2 destination racks, so it chooses this option.

After choosing the number of Source Racks in a Batch, the program empties the testing array and begins adding sample numbers. First it adds the highest sample number, and then it calculates the ratios of each sample number's frequency to the total sample number of the available racks, truncating the result into an integer. Using this ratio, it adds the corresponding amount of each sample number, and if there is more than 1 spot leftover, fills all except 1 with the lowest sample numbers available. (Note: there is a possible bug here if there is an unexpectedly high number of racks with high sample numbers, since the use of ratios may result in there being no extra spot, which is crucial to the next step).

For the final spot, it calculates the ideal sample number for it to have and checks if it is available based on the sample_frequencies array. If it is, it adds the final sample number to the testing array. Then, it adds a corresponding source rack to the batch for every number in the testing array. Then, it moves onto the next batch.

If the ideal last spot is not available, the program checks if the last spot is less than 1. If so, it decreases the total sample number in the testing array by removing the second-highest number (which was added as part of the ratios portion and should still be a relatively frequent number) and adds a smaller number, repeating until the last spot is greater than 1 and available. If the last spot is not less than 1, the program increases the total sample number in the testing array by removing the smallest sample number and adding a larger number, repeating until the last spot is available. If this process reaches the highest sample number available and the total samples in the testing array still does not reach the goal number of samples, it approximates by adding the largest possible sample number - the rack will not be full, but it will be as close as possible. After finalizing the spots, the program moves onto the next batch.

After distributing all the racks, the program asks the user if they would like an overview. The overview includes the number of batches, the number of source racks in each Batch, and the number of spots filled in the destination racks of each Batch. Then, it exports the final results to a file, which explicitly tells the user which source racks are in which batches using the rack's id. The format of the file is comma separated and can be copy and pasted directly into excel, which is what the researcher requested.
